---
alwaysApply: true
---
# Clerk Authentication & Authorization Rules

This project uses **Clerk** for authentication and authorization. All user data access MUST be properly secured to ensure users can only access their own data and never access data belonging to other users.

**IMPORTANT**: This app uses **modal-based authentication** with Clerk components (SignInButton, SignUpButton with `mode="modal"`). There are **NO dedicated sign-in pages**. Users who attempt to access protected routes while unauthenticated are redirected to the homepage where they can authenticate using the modal-based sign-in components.

**CRITICAL**: All successful sign-in and sign-up operations MUST redirect users to the `/dashboard` page. This ensures a consistent post-authentication experience and proper user flow.

## Core Authentication Requirements

### 1. User Authentication
- All authentication is handled by Clerk
- Never implement custom auth logic - always use Clerk's provided methods
- Authentication state is managed through Clerk's hooks and server-side utilities

### 2. User Identification
- Always use Clerk's `userId` from `auth()` or `currentUser()` for data operations
- The `userId` is stored in database tables (e.g., `decksTable.userId`) for data ownership
- Never trust client-side user IDs - always get them server-side

```typescript
// ✅ CORRECT - Server-side user identification
import { auth, currentUser } from '@clerk/nextjs/server';

export async function getUserDecks() {
  const { userId } = auth();
  if (!userId) throw new Error('Unauthorized');
  
  return await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));
}
```

## Post-Authentication Redirects - MANDATORY

**CRITICAL**: All authentication components MUST include proper redirect URLs to ensure users are sent to the dashboard page after successful authentication.

### 1. Required Redirect Pattern
All SignInButton and SignUpButton components MUST use the following pattern:

```typescript
// ✅ REQUIRED - SignInButton with dashboard redirect
<SignInButton mode="modal" forceRedirectUrl="/dashboard">
  <Button variant="outline">Sign In</Button>
</SignInButton>

// ✅ REQUIRED - SignUpButton with dashboard redirect
<SignUpButton mode="modal" forceRedirectUrl="/dashboard">
  <Button>Sign Up</Button>
</SignUpButton>
```

### 2. Redirect Parameters
- **`forceRedirectUrl="/dashboard"`**: MANDATORY for all authentication buttons
- **`mode="modal"`**: REQUIRED for modal-based authentication
- **Dashboard URL**: Must always be `/dashboard` - never omit or use different URLs

### 3. Environment Variables (Optional)
For global redirect configuration, set in `.env.local`:
```env
NEXT_PUBLIC_CLERK_AFTER_SIGN_IN_URL=/dashboard
NEXT_PUBLIC_CLERK_AFTER_SIGN_UP_URL=/dashboard
```

However, **ALWAYS** include `forceRedirectUrl="/dashboard"` in components for explicit control.

## Authorization Patterns

### 1. Database Query Authorization
**CRITICAL**: Every database query that accesses user data MUST include the user ID filter:

```typescript
// ✅ CORRECT - Always filter by userId
const userDecks = await db
  .select()
  .from(decksTable)
  .where(eq(decksTable.userId, userId));

// ✅ CORRECT - Multi-condition queries still include userId
const userDeck = await db
  .select()
  .from(decksTable)
  .where(and(
    eq(decksTable.id, deckId),
    eq(decksTable.userId, userId) // REQUIRED
  ));

// ❌ FORBIDDEN - Never query without userId filter
const allDecks = await db.select().from(decksTable);
const deckById = await db
  .select()
  .from(decksTable)
  .where(eq(decksTable.id, deckId)); // Missing userId check!
```

### 2. Resource Ownership Verification
Always verify ownership before performing operations:

```typescript
// ✅ CORRECT - Verify ownership before operations
async function updateDeck(deckId: string, updates: any) {
  const { userId } = auth();
  if (!userId) throw new Error('Unauthorized');
  
  // First verify the user owns this deck
  const deck = await db
    .select()
    .from(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ));
    
  if (!deck.length) throw new Error('Deck not found or unauthorized');
  
  // Then perform the update
  return await db
    .update(decksTable)
    .set({ ...updates, updatedAt: new Date() })
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId) // Still include userId in update
    ));
}
```

### 3. Nested Resource Authorization
For nested resources (cards belonging to decks), verify the complete ownership chain:

```typescript
// ✅ CORRECT - Verify user owns the deck that contains the card
async function updateCard(cardId: string, updates: any) {
  const { userId } = auth();
  if (!userId) throw new Error('Unauthorized');
  
  // Verify through join that user owns the deck containing this card
  const cardWithDeck = await db
    .select()
    .from(cardsTable)
    .innerJoin(decksTable, eq(cardsTable.deckId, decksTable.id))
    .where(and(
      eq(cardsTable.id, cardId),
      eq(decksTable.userId, userId) // Verify ownership through deck
    ));
    
  if (!cardWithDeck.length) throw new Error('Card not found or unauthorized');
  
  return await db
    .update(cardsTable)
    .set({ ...updates, updatedAt: new Date() })
    .where(eq(cardsTable.id, cardId));
}
```

## Route Protection

### 1. Middleware Configuration
Ensure [src/middleware.ts](mdc:src/middleware.ts) properly protects routes and redirects to homepage:

```typescript
import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server';
import { NextResponse } from 'next/server';

const isProtectedRoute = createRouteMatcher([
  '/dashboard(.*)',
  '/decks(.*)',
  '/cards(.*)',
  '/api/decks(.*)',
  '/api/cards(.*)'
]);

export default clerkMiddleware((auth, req) => {
  if (isProtectedRoute(req)) {
    const { userId } = auth();
    if (!userId) {
      // Redirect to homepage instead of sign-in page
      return NextResponse.redirect(new URL('/', req.url));
    }
  }
});
```

### 2. API Route Protection
All API routes accessing user data must be protected:

```typescript
// ✅ CORRECT - Protected API route
import { auth } from '@clerk/nextjs/server';

export async function GET() {
  const { userId } = auth();
  if (!userId) {
    return new Response('Unauthorized', { status: 401 });
  }
  
  const userDecks = await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId));
    
  return Response.json(userDecks);
}
```

### 3. Server Action Protection
All Server Actions must verify user authentication:

```typescript
// ✅ CORRECT - Protected server action
'use server';

export async function createDeck(formData: FormData) {
  const { userId } = auth();
  if (!userId) throw new Error('Unauthorized');
  
  const name = formData.get('name') as string;
  const description = formData.get('description') as string;
  
  return await db
    .insert(decksTable)
    .values({ name, description, userId })
    .returning();
}
```

## Client-Side Authentication

### 1. Component Protection
Use Clerk's client components for conditional rendering with MANDATORY dashboard redirects:

```typescript
import { useAuth, useUser } from '@clerk/nextjs';
import { SignInButton, SignUpButton, SignOutButton } from '@clerk/nextjs';
import { Button } from '@/components/ui/button';

function ProtectedComponent() {
  const { isSignedIn, userId } = useAuth();
  
  if (!isSignedIn) {
    return (
      <div className="flex gap-2">
        {/* MANDATORY: Include forceRedirectUrl="/dashboard" */}
        <SignInButton mode="modal" forceRedirectUrl="/dashboard">
          <Button variant="outline">Sign In</Button>
        </SignInButton>
        <SignUpButton mode="modal" forceRedirectUrl="/dashboard">
          <Button>Sign Up</Button>
        </SignUpButton>
      </div>
    );
  }
  
  return (
    <div>
      <UserContent />
      <SignOutButton>
        <Button variant="outline">Sign Out</Button>
      </SignOutButton>
    </div>
  );
}
```

### 2. Authentication Buttons Component Pattern
Create reusable authentication components that ALWAYS redirect to dashboard:

```typescript
'use client';

import { Button } from '@/components/ui/button';
import { SignInButton, SignUpButton, useAuth } from '@clerk/nextjs';

export function AuthButtons() {
  const { isSignedIn } = useAuth();
  
  if (isSignedIn) return null;
  
  return (
    <div className="flex gap-2">
      {/* CRITICAL: ALWAYS include forceRedirectUrl="/dashboard" */}
      <SignInButton mode="modal" forceRedirectUrl="/dashboard">
        <Button variant="outline">Sign In</Button>
      </SignInButton>
      
      <SignUpButton mode="modal" forceRedirectUrl="/dashboard">
        <Button>Sign Up</Button>
      </SignUpButton>
    </div>
  );
}
```

### 3. Navigation Bar Authentication
For navigation components, maintain consistent dashboard redirects:

```typescript
import { UserButton, useAuth } from '@clerk/nextjs';
import { AuthButtons } from '@/components/auth-buttons';

export function Navbar() {
  const { isSignedIn } = useAuth();
  
  return (
    <nav className="flex justify-between items-center p-4">
      <h1>Flashcard App</h1>
      
      {isSignedIn ? (
        <UserButton afterSignOutUrl="/" />
      ) : (
        <AuthButtons />
      )}
    </nav>
  );
}
```

## Security Best Practices

### 1. Input Validation
- Always validate that user-provided IDs exist and belong to the authenticated user
- Never trust client-side data for authorization decisions
- Use TypeScript for compile-time safety

### 2. Error Handling
- Don't leak information about other users' data in error messages
- Return generic "not found" errors instead of "unauthorized" when appropriate
- Log security violations for monitoring

```typescript
// ✅ CORRECT - Generic error that doesn't leak info
if (!userDeck.length) {
  throw new Error('Deck not found'); // Don't reveal if it exists for other users
}
```

### 3. Data Exposure Prevention
- Never return user data without proper filtering
- Use `SELECT` statements that explicitly include userId filters
- Avoid wildcards that might expose unauthorized data

## Prohibited Patterns

❌ **NEVER** do any of the following:
- Query database tables without userId filters when accessing user data
- Trust client-side authentication state for server-side authorization
- Use hardcoded user IDs or bypass Clerk authentication
- Expose one user's data to another user through any means
- Implement custom authentication logic alongside Clerk
- Cache user data without proper user-specific keys
- Share database connections between different user sessions
- **Omit `forceRedirectUrl="/dashboard"` from SignInButton or SignUpButton components**
- **Use redirect URLs other than `/dashboard` for post-authentication flows**
- **Create authentication buttons without modal mode (`mode="modal"` is required)**
- **Allow users to be redirected to unexpected pages after successful authentication**

### ❌ FORBIDDEN Authentication Patterns:

```typescript
// ❌ FORBIDDEN - No redirect URL specified
<SignInButton mode="modal">
  <Button>Sign In</Button>
</SignInButton>

// ❌ FORBIDDEN - Wrong redirect URL
<SignInButton mode="modal" forceRedirectUrl="/profile">
  <Button>Sign In</Button>
</SignInButton>

// ❌ FORBIDDEN - Missing modal mode
<SignInButton forceRedirectUrl="/dashboard">
  <Button>Sign In</Button>
</SignInButton>

// ❌ FORBIDDEN - Using redirect mode instead of modal
<SignInButton mode="redirect" signInUrl="/sign-in">
  <Button>Sign In</Button>
</SignInButton>
```

## Testing Authorization

When testing, always verify:
1. Users can only see their own data
2. Users cannot access other users' resources by changing IDs
3. Unauthenticated requests are properly rejected
4. All database queries include proper authorization filters
5. API endpoints return 401/403 for unauthorized access attempts
6. **All sign-in operations redirect to `/dashboard` after successful authentication**
7. **All sign-up operations redirect to `/dashboard` after successful authentication**
8. **Authentication buttons include proper `forceRedirectUrl="/dashboard"` parameter**
9. **Modal authentication works properly and redirects correctly**

### Authentication Flow Testing Checklist:
- [ ] Sign-in button uses `mode="modal"` and `forceRedirectUrl="/dashboard"`
- [ ] Sign-up button uses `mode="modal"` and `forceRedirectUrl="/dashboard"`
- [ ] Successful sign-in redirects user to dashboard page
- [ ] Successful sign-up redirects user to dashboard page
- [ ] Modal closes properly after authentication
- [ ] User sees dashboard content immediately after authentication
- [ ] No unexpected redirects to other pages occur

Remember: **Data isolation is critical**. Every database operation involving user data must include proper authorization checks. **Post-authentication user experience is equally important** - users must always land on the dashboard page after successful authentication.