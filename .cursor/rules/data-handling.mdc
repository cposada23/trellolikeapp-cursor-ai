---
alwaysApply: true
---
# Data Handling & Server-Side Architecture Rules

This project enforces strict server-side data handling patterns for security, performance, and maintainability. All data operations must follow these architectural guidelines.

## Core Architecture Requirements

### 1. Database Query Helper Functions - MANDATORY
**CRITICAL**: All database operations MUST be abstracted into helper functions located in the `src/db/queries/` directory. No direct database operations are allowed in Server Components or Server Actions.

```typescript
// ✅ CORRECT - Query helper functions in src/db/queries/deck-queries.ts
import db from '@/db';
import { decksTable, cardsTable } from '@/db/schema';
import { auth } from '@clerk/nextjs/server';
import { eq, and, desc } from 'drizzle-orm';
import type { CreateDeckInput, UpdateDeckInput } from '@/lib/schemas';

export async function getUserDecks() {
  const { userId } = auth();
  if (!userId) throw new Error('Unauthorized');
  
  return await db
    .select()
    .from(decksTable)
    .where(eq(decksTable.userId, userId))
    .orderBy(desc(decksTable.createdAt));
}

export async function getDeckById(deckId: string) {
  const { userId } = auth();
  if (!userId) throw new Error('Unauthorized');
  
  const deck = await db
    .select()
    .from(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ));
    
  return deck[0] || null;
}

export async function getDeckWithCards(deckId: string) {
  const { userId } = auth();
  if (!userId) throw new Error('Unauthorized');
  
  return await db.query.decksTable.findFirst({
    where: and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ),
    with: { cards: true }
  });
}

export async function createDeck(input: CreateDeckInput) {
  const { userId } = auth();
  if (!userId) throw new Error('Unauthorized');
  
  const result = await db
    .insert(decksTable)
    .values({
      ...input,
      userId,
      createdAt: new Date(),
      updatedAt: new Date()
    })
    .returning();
    
  return result[0];
}

export async function updateDeck(deckId: string, input: UpdateDeckInput) {
  const { userId } = auth();
  if (!userId) throw new Error('Unauthorized');
  
  const result = await db
    .update(decksTable)
    .set({ 
      ...input, 
      updatedAt: new Date() 
    })
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ))
    .returning();
    
  return result[0] || null;
}

export async function deleteDeck(deckId: string) {
  const { userId } = auth();
  if (!userId) throw new Error('Unauthorized');
  
  await db
    .delete(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ));
}
```

### 2. Data Retrieval - Server Components with Query Functions
**MANDATORY**: Server Components MUST call query helper functions instead of performing direct database operations.

```typescript
// ✅ CORRECT - Server Component using query helper functions
import { getUserDecks } from '@/db/queries/deck-queries';
import { DeckCard } from '@/components/deck-card';

export default async function DecksPage() {
  const userDecks = await getUserDecks();
  
  return (
    <div>
      {userDecks.map(deck => (
        <DeckCard key={deck.id} deck={deck} />
      ))}
    </div>
  );
}

// ✅ CORRECT - Server Component with specific deck data
import { getDeckWithCards } from '@/db/queries/deck-queries';

export default async function DeckPage({ params }: { params: { id: string } }) {
  const deck = await getDeckWithCards(params.id);
  
  if (!deck) {
    return <div>Deck not found</div>;
  }
  
  return (
    <div>
      <h1>{deck.name}</h1>
      <p>{deck.description}</p>
      <div>
        {deck.cards.map(card => (
          <div key={card.id}>{card.front}</div>
        ))}
      </div>
    </div>
  );
}
```

```typescript
// ❌ FORBIDDEN - Client Component with data fetching
'use client';
import { useEffect, useState } from 'react';

export default function DecksPage() {
  const [decks, setDecks] = useState([]);
  
  useEffect(() => {
    // ❌ NEVER fetch data in Client Components
    fetch('/api/decks')
      .then(res => res.json())
      .then(setDecks);
  }, []);
  
  return <div>...</div>;
}
```

### 3. Database Mutations - Server Actions with Query Functions
**MANDATORY**: Server Actions MUST call query helper functions for all database mutations. Server Actions handle validation, path revalidation, and error handling, while query functions handle the actual database operations.

```typescript
// ✅ CORRECT - Server Actions using query helper functions
'use server';

import { createDeck, updateDeck, deleteDeck } from '@/db/queries/deck-queries';
import { CreateDeckSchema, UpdateDeckSchema, type CreateDeckInput, type UpdateDeckInput } from '@/lib/schemas';
import { revalidatePath } from 'next/cache';
import { redirect } from 'next/navigation';

export async function createDeckAction(input: CreateDeckInput) {
  // Validate input with Zod
  const validatedData = CreateDeckSchema.parse(input);
  
  try {
    // Call query helper function
    const newDeck = await createDeck(validatedData);
    
    // Handle post-mutation tasks
    revalidatePath('/decks');
    revalidatePath('/dashboard');
    
    return { success: true, data: newDeck };
  } catch (error) {
    console.error('Failed to create deck:', error);
    return { success: false, error: 'Failed to create deck' };
  }
}

export async function updateDeckAction(deckId: string, input: UpdateDeckInput) {
  const validatedData = UpdateDeckSchema.parse(input);
  
  try {
    const updatedDeck = await updateDeck(deckId, validatedData);
    
    if (!updatedDeck) {
      return { success: false, error: 'Deck not found or unauthorized' };
    }
    
    revalidatePath('/decks');
    revalidatePath(`/decks/${deckId}`);
    
    return { success: true, data: updatedDeck };
  } catch (error) {
    console.error('Failed to update deck:', error);
    return { success: false, error: 'Failed to update deck' };
  }
}

export async function deleteDeckAction(deckId: string) {
  try {
    await deleteDeck(deckId);
    
    revalidatePath('/decks');
    revalidatePath('/dashboard');
    
    return { success: true };
  } catch (error) {
    console.error('Failed to delete deck:', error);
    return { success: false, error: 'Failed to delete deck' };
  }
}

// ✅ CORRECT - Server Action with redirect after successful creation
export async function createDeckAndRedirect(input: CreateDeckInput) {
  const validatedData = CreateDeckSchema.parse(input);
  
  try {
    const newDeck = await createDeck(validatedData);
    revalidatePath('/decks');
    redirect(`/decks/${newDeck.id}`);
  } catch (error) {
    console.error('Failed to create deck:', error);
    throw new Error('Failed to create deck');
  }
}
```

### 4. Data Validation - Zod Schemas Required
**MANDATORY**: All data validation MUST use Zod schemas. Every Server Action input MUST be validated with Zod.

```typescript
// ✅ CORRECT - Zod schema definitions
import { z } from 'zod';

export const CreateDeckSchema = z.object({
  name: z.string().min(1, 'Name is required').max(100, 'Name too long'),
  description: z.string().max(500, 'Description too long').optional(),
});

export const UpdateDeckSchema = z.object({
  name: z.string().min(1, 'Name is required').max(100, 'Name too long').optional(),
  description: z.string().max(500, 'Description too long').optional(),
});

export const CreateCardSchema = z.object({
  front: z.string().min(1, 'Front side is required'),
  back: z.string().min(1, 'Back side is required'),
  deckId: z.string().uuid('Invalid deck ID'),
});

// Export TypeScript types from Zod schemas
export type CreateDeckInput = z.infer<typeof CreateDeckSchema>;
export type UpdateDeckInput = z.infer<typeof UpdateDeckSchema>;
export type CreateCardInput = z.infer<typeof CreateCardSchema>;
```

### 5. Query Helper Function Guidelines
**MANDATORY**: Query helper functions MUST follow these strict patterns:

```typescript
// ✅ CORRECT - Query helper function pattern
// src/db/queries/card-queries.ts
import db from '@/db';
import { cardsTable, decksTable } from '@/db/schema';
import { auth } from '@clerk/nextjs/server';
import { eq, and } from 'drizzle-orm';
import type { CreateCardInput, UpdateCardInput } from '@/lib/schemas';

export async function getCardsByDeck(deckId: string) {
  const { userId } = auth();
  if (!userId) throw new Error('Unauthorized');
  
  // Verify user owns the deck first
  const deck = await db
    .select({ id: decksTable.id })
    .from(decksTable)
    .where(and(
      eq(decksTable.id, deckId),
      eq(decksTable.userId, userId)
    ));
    
  if (!deck.length) throw new Error('Deck not found or unauthorized');
  
  return await db
    .select()
    .from(cardsTable)
    .where(eq(cardsTable.deckId, deckId));
}

export async function createCard(input: CreateCardInput) {
  const { userId } = auth();
  if (!userId) throw new Error('Unauthorized');
  
  // Verify user owns the deck
  const deck = await db
    .select({ id: decksTable.id })
    .from(decksTable)
    .where(and(
      eq(decksTable.id, input.deckId),
      eq(decksTable.userId, userId)
    ));
    
  if (!deck.length) throw new Error('Deck not found or unauthorized');
  
  const result = await db
    .insert(cardsTable)
    .values({
      ...input,
      createdAt: new Date(),
      updatedAt: new Date()
    })
    .returning();
    
  return result[0];
}

// Query functions MUST handle their own authorization
// Query functions MUST return properly typed data
// Query functions MUST NOT handle revalidation (that's for Server Actions)
```

```typescript
// ❌ FORBIDDEN - Direct database operations in Server Actions
'use server';

import db from '@/db';
import { decksTable } from '@/db/schema';

// ❌ NEVER do this - Direct database operations in Server Actions
export async function createDeck(input: any) {
  const result = await db.insert(decksTable).values(input); // Forbidden
  return result;
}

// ❌ FORBIDDEN - Using FormData as parameter type
export async function createDeckBad(formData: FormData) {
  const name = formData.get('name') as string; // Unsafe type assertion
  const description = formData.get('description') as string;
  
  // No validation, unsafe data handling
  const result = await db.insert(decksTable).values({ name, description });
  return result;
}

// ❌ FORBIDDEN - No validation with query helpers
export async function createDeckNoValidation(input: any) {
  // No Zod validation before calling query helper - security risk
  const result = await createDeck(input); // Should validate first
  return result;
}
```

## Form Handling Patterns

### 1. Client-Side Form Submission
```typescript
// ✅ CORRECT - Client Component calling Server Action
'use client';

import { createDeck } from '@/actions/deck-actions';
import { CreateDeckSchema, type CreateDeckInput } from '@/lib/schemas';
import { useState } from 'react';

export function CreateDeckForm() {
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  async function handleSubmit(event: React.FormEvent<HTMLFormElement>) {
    event.preventDefault();
    setIsSubmitting(true);
    
    const formData = new FormData(event.currentTarget);
    const input: CreateDeckInput = {
      name: formData.get('name') as string,
      description: formData.get('description') as string || undefined,
    };
    
    try {
      // Client-side validation (optional but recommended)
      const validatedInput = CreateDeckSchema.parse(input);
      
      // Call Server Action with validated data
      await createDeck(validatedInput);
    } catch (error) {
      console.error('Failed to create deck:', error);
    } finally {
      setIsSubmitting(false);
    }
  }
  
  return (
    <form onSubmit={handleSubmit}>
      <input name="name" required />
      <textarea name="description" />
      <button type="submit" disabled={isSubmitting}>
        Create Deck
      </button>
    </form>
  );
}
```

### 2. React Hook Form Integration
```typescript
// ✅ CORRECT - Using React Hook Form with Zod
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { CreateDeckSchema, type CreateDeckInput } from '@/lib/schemas';
import { createDeck } from '@/actions/deck-actions';

export function CreateDeckForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting }
  } = useForm<CreateDeckInput>({
    resolver: zodResolver(CreateDeckSchema)
  });
  
  async function onSubmit(data: CreateDeckInput) {
    try {
      await createDeck(data);
    } catch (error) {
      console.error('Failed to create deck:', error);
    }
  }
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input {...register('name')} />
      {errors.name && <span>{errors.name.message}</span>}
      
      <textarea {...register('description')} />
      {errors.description && <span>{errors.description.message}</span>}
      
      <button type="submit" disabled={isSubmitting}>
        Create Deck
      </button>
    </form>
  );
}
```

## Error Handling

### 1. Server Action Error Handling
```typescript
// ✅ CORRECT - Proper error handling in Server Actions
'use server';

export async function createDeck(input: CreateDeckInput) {
  try {
    const validatedData = CreateDeckSchema.parse(input);
    
    const { userId } = auth();
    if (!userId) {
      return { error: 'Unauthorized' };
    }
    
    const result = await db
      .insert(decksTable)
      .values({
        ...validatedData,
        userId
      })
      .returning();
      
    revalidatePath('/decks');
    return { success: true, data: result[0] };
    
  } catch (error) {
    if (error instanceof z.ZodError) {
      return { error: 'Validation failed', details: error.errors };
    }
    
    console.error('Failed to create deck:', error);
    return { error: 'Failed to create deck' };
  }
}
```

## File Organization

### 1. Query Helper Functions Location - MANDATORY
- **ALL** database query functions MUST be in [src/db/queries/](mdc:src/db/queries/) directory
- Organize by domain: `deck-queries.ts`, `card-queries.ts`, `user-queries.ts`
- Each file exports functions related to a specific database table/domain

```typescript
// ✅ CORRECT - Query organization
// src/db/queries/deck-queries.ts
export async function getUserDecks() { ... }
export async function getDeckById(id: string) { ... }
export async function createDeck(input: CreateDeckInput) { ... }
export async function updateDeck(id: string, input: UpdateDeckInput) { ... }
export async function deleteDeck(id: string) { ... }

// src/db/queries/card-queries.ts
export async function getCardsByDeck(deckId: string) { ... }
export async function getCardById(id: string) { ... }
export async function createCard(input: CreateCardInput) { ... }
export async function updateCard(id: string, input: UpdateCardInput) { ... }
export async function deleteCard(id: string) { ... }
```

### 2. Schema Location
- All Zod schemas should be in [src/lib/schemas.ts](mdc:src/lib/schemas.ts)
- Export both schemas and inferred types

### 3. Server Actions Location
- Group related Server Actions in [src/actions/](mdc:src/actions/) directory
- Use descriptive filenames: `deck-actions.ts`, `card-actions.ts`
- Server Actions call query helper functions, handle validation and revalidation

### 4. Complete Architecture Structure
```typescript
// ✅ CORRECT - Complete file organization
// src/lib/schemas.ts
export const CreateDeckSchema = z.object({...});
export type CreateDeckInput = z.infer<typeof CreateDeckSchema>;

// src/db/queries/deck-queries.ts
import type { CreateDeckInput } from '@/lib/schemas';
export async function createDeck(input: CreateDeckInput) {
  // Database operations with auth checks
}

// src/actions/deck-actions.ts
'use server';
import { createDeck } from '@/db/queries/deck-queries';
import { CreateDeckSchema, type CreateDeckInput } from '@/lib/schemas';

export async function createDeckAction(input: CreateDeckInput) {
  const validatedData = CreateDeckSchema.parse(input);
  const result = await createDeck(validatedData);
  revalidatePath('/decks');
  return result;
}

// src/app/decks/page.tsx (Server Component)
import { getUserDecks } from '@/db/queries/deck-queries';
export default async function DecksPage() {
  const decks = await getUserDecks();
  return <div>...</div>;
}
```

### 5. Import Patterns
```typescript
// ✅ CORRECT - Import patterns
// Query functions (read operations)
import { getUserDecks, getDeckById } from '@/db/queries/deck-queries';

// Server Actions (write operations)  
import { createDeckAction, updateDeckAction } from '@/actions/deck-actions';

// Schemas and types
import { CreateDeckSchema, type CreateDeckInput } from '@/lib/schemas';
```

## Prohibited Patterns

❌ **NEVER** do any of the following:
- **Direct database operations in Server Components or Server Actions** - MUST use query helper functions
- **Fetch data in Client Components** - use Server Components with query helper functions instead
- **Perform database operations outside of `src/db/queries/` directory** - centralize all database access
- **Skip calling query helper functions** - Server Actions must delegate to query functions
- **Use FormData as Server Action parameter types** - use proper TypeScript types with Zod
- **Skip Zod validation for any user input** - validate before calling query helpers
- **Use `any` types instead of proper Zod-inferred types** - maintain type safety
- **Perform database operations without proper authentication checks** - query helpers must verify auth
- **Forget to revalidate paths after mutations** - Server Actions must handle revalidation
- **Mix authentication logic between query helpers and Server Actions** - auth belongs in query helpers
- **Create query helper functions without proper error handling** - handle auth and validation errors
- **Bypass the query helper pattern for "simple" operations** - ALL database operations use this pattern

## Architecture Benefits

### 1. **Centralized Data Access**
- All database operations in one location (`src/db/queries/`)
- Easier to maintain, test, and debug
- Consistent authentication and authorization patterns
- Reusable across multiple Server Components and Server Actions

### 2. **Clear Separation of Concerns**
- **Query Helper Functions**: Database operations, authentication, data transformation
- **Server Actions**: Input validation, calling query helpers, revalidation, error handling
- **Server Components**: Calling query helpers, rendering data
- **Client Components**: UI interactions, calling Server Actions

### 3. **Type Safety & Validation**
- Zod schemas provide compile-time and runtime type safety
- Query helper functions return properly typed data
- Server Actions validate inputs before database operations

### 4. **Performance & Caching**
- Next.js automatic caching works optimally with Server Components
- Query helper functions enable easy caching strategies
- Centralized revalidation patterns

## Performance Considerations

1. **Streaming**: Use React's streaming capabilities with Server Components
2. **Revalidation**: Server Actions call `revalidatePath()` after mutations
3. **Caching**: Leverage Next.js automatic caching for Server Components
4. **Query Optimization**: Centralized query helpers enable easy performance optimizations
5. **Database Indexing**: Query helpers make it easier to identify and optimize slow queries

## Migration from Direct Database Operations

If you have existing code with direct database operations:

1. **Extract database operations** into query helper functions in `src/db/queries/`
2. **Update Server Components** to call query helper functions
3. **Update Server Actions** to call query helper functions and handle revalidation
4. **Ensure authentication checks** are moved to query helper functions
5. **Test thoroughly** to ensure data access patterns work correctly

Remember: This architecture ensures type safety, security, performance, and maintainability by centralizing all database operations into reusable, properly authenticated helper functions.